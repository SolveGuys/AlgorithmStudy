
# 프로그래머스 92342 양궁 대회
 
### 난이도 : 레벨 2
[문제 보러가기](https://school.programmers.co.kr/learn/courses/30/lessons/92342#)
  
## 브루트 포스, 비트마스킹
과녁이 11종류이고 여기에 맞춰 쏘는 방법은 2^11 = 2048개밖에 되지 않기 때문에, 모두 세어도 시간안에 충분히 풀 수 있다.   
테스트 22 〉	통과 (0.17ms, 4.21MB)

## 자료구조
벡터 정도만 써도 딱히 필요없다.

## 알고리즘
11개의 비트를 사용할 int 하나를 사용하고, 이를 i라고 하자.  
i의 최소 비트는 0점, 막둘 비트는 1점, 뒤에서 세번째 비트는 2점, 하는 식으로 10점까지 11개 비트만 사용해주면 되며,  
```for (int i = 0; i < 1 << 11; i++)```에서 비트가 1인 경우는 챔피언이 점수를 따는 경우, 0이면 안 따는 경우로 세도록 한다.  
도전자보다 챔피언이 과녁에 더 많이 맞춰야 점수를 따므로 해당 비트가 1이면 도전자보다 화살을 하나만 더 쏘면서 넘어간다.  

```c++
for (int j = 0; j < 11; j++) 
{
    if ((1 << j) & i) 
    {
        arrow_count += info[10 - j] + 1;
        next_status[10 - j] = info[10 - j] + 1;
    }
    
    if (arrow_count > n)
        break;
}
```


## 주의할 점
(나도 당한)테스크케이스 8번, 18번 틀리는 경우 :  
최대 점수차를 내는 경우의 수가 여러가지인 경우, 가장 낮은 점수를 맞춘 경우의 수를 우선시해주어야 한다.  
이런 조건은 특정 알고리즘이나 탐색 순서를 강제하는 것 같은데,  
dfs 같은 걸로는 알고리즘 내에서 가능하겠지만 비트마스킹으로는 가장 낮은 점수를 맞추는 경우를 순서에 포함시킬 수 없어 따로 함수를 만들어주었다.  
```c++
bool bHigher(const std::vector<int>& left, const std::vector<int>& right)
{
    int left_idx = 1e9;
    for(int i = 10; i >= 0; i--)
    {
        if(left[i] > 0)
        {
            left_idx = i;
            break;
        }
    }
    int right_idx = 1e9;
    for(int j = 10; j >= 0; j--)
    {
        if(right[j] > 0)
        {
            right_idx = j;
            break;
        }
    }
    return left_idx > right_idx;
}
```
내가 선호하는 방식은 아니지만, 실전에서는 어느정도 타협할 수 있어야 할 것 같다.

## 느낀 점
여전히 카카오 문제는 껄끄럽지만, 실전에서는 원하는 문제만 풀 수는 없으니 자주 연습해두는게 좋을 것 같다.  
질문하기에서 적지 않은 사람들이 언급하는 걸 보면 나만 그렇게 느끼는 건 아닌듯.

## refs
[ref 1](https://velog.io/@mrbartrns/알고리즘-프로그래머스-양궁대회-python)

## 코드
[코드 보러가기](./prog92342.cpp)