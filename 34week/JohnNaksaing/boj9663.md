# 백준 9663 N-Queen
 
### 난이도 : 골드 4
[문제 보러가기](https://www.acmicpc.net/problem/9663)
  
## N개 여왕 문제
전형적인 백트래킹 문제.  
메모리 	2020KB, 시간 4028ms  
N=0부터 N=15까지 모두 구하고 배열에 집어넣는 꼼수를 쓰면 1112KB, 0ms  
  
## 자료구조
배열이나 벡터 대신 포인터를 이용해 동적 배열을 사용해보았다.  

## 알고리즘
백트래킹 없이 단순 bfs/dfs로만 풀면 N = 8,9부터 슬슬 일반적인 PC에서는 메모리가 터져나가는 꼴을 볼 수 있다.  
그렇기 때문에 백트래킹을 통해 경우의 수를 줄여주는 것으로 문제를 풀 수 있다.  
```promising()```으로 bool을 반환하여 앞에서 틀렸으면 어차피 뒤에서 맞아봤자 정답이 아니기 때문에 false인 경우는 미리 쳐내는 것이다.

동적 배열 board는 각 여왕이 한 줄에 하나씩만 존재할 수 있기 때문에, 특정 줄을 인덱스로 받고 해당 칸을 값으로 나타내는 int[]이다.  
for()를 돌려 ```board[here]```에 값을 0부터 n-1까지 넣고, 그게 지금까지 채워 온 여왕들과 충돌하지 않으면 dfs(here+1)로 다음을 탐색하여 구현하였다.


## 느낀 점
아는것과 푸는것은 같지 않다는 사실을 또 한번 느끼게 되었다.  
나중에 또 풀어봐야지...

## 주의할 점
bfs로 풀 때 visited배열을 까먹으면 제출할 때 시행착오를 몇번 더 거치게 된다.

## refs

## 코드
[코드 보러가기](./boj9663.cpp)
