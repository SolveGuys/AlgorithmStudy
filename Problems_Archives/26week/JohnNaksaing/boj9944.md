# 백준 9944 NxM 보드 완주하기
 
### 난이도 : 골드 3

[문제 보러가기](https://www.acmicpc.net/problem/9944)
  
## dfs
구현해주어야 하는 게 많은 탐색 문제였습니다.    
메모리 2024KB, 시간 88ms
  
## 자료구조
보통 배열을 잡을 때 0 ~ N-1 범위를 설정해주는 걸 선호했지만
탐색 시 범위 판정을 해주는 인라인 함수 bValid 등을 굳이 만들고 싶지 않아 0~32까지 패딩을 만들어 주었습니다.  
padding을 이용하여 ```bValid(int x, int y)``` 함수 호출을 배제할 수 있습니다.  


## 알고리즘
진행-dfs-복원 처리를 통해 따로 임시 메모리를 잡아 원본 상태를 복사하지 않고 빠른 시간 안에 처리할 수 있습니다.  
임시로 30*30 크기를 잡아 진행상태를 복사하여 배열 전체를 매개변수로 넘기는 방법은 디버깅이 쉽고 직관적이지만 메모리를 많이 잡아먹어 stack에서 문제가 생길 수 있고,  
cache-miss rate가 높아 시간차이가 많이 날 수 있으니 구현에 유의하시면 좋을 것 같습니다(80 ~ 90ms vs 550 ~ 560ms).

### 진행
장애물이나 지나온 길을 만날때까지 한 방향으로 계속 진행하는 것이 구현사항이기 때문에, while을 이용하면 적절하게 구현할 수 있습니다.  

```c++
while (!bVisited[nx][ny]) 
{
    bVisited[nx][ny] = true;
    next_reached++;
    nx += dx[dir];
    ny += dy[dir];
}
nx -= dx[dir]; ny -= dy[dir];
```
loop를 빠져 나왔을 때 bVisited가 true인 지점을 밟고 있으므로, 뒤로 한 칸 물러나줍니다.  
bVisited는 벽(입력에서 '*'으로 주어진 곳)이거나, 이미 지나온 길이거나, padding인 경우 true입니다.  

### end of file
이 문제는 입력값의 범위가 없어 eof까지 입력을 계속해서 받아야 합니다.  
[여러가지 방법](https://takeknowledge.tistory.com/20)이 있으니 참고하면 좋을 것 같습니다.  
scanf를 쓸 것이냐, std::cin을 사용할 것이냐는 PS에서 시간차이가 날 수 있으니 std::endl 처리 등 io를 더 빠르게 만드는 방법들을 참고하시면 도움이 될 수 있습니다.  


## 코드
[코드 보러가기](./boj9944.cpp)

## refs
 - [참고한 풀이](https://dongwook-chang.tistory.com/57)
 - [input 부분에서 도움을 받은 풀이](https://kukekyakya.tistory.com/317)


## 느낀 점
구현, 백트래킹으로 시간초과 예방, input 처리 등 신경써주어야 하는 게 너무 많은 문제였다.  
구현 중 알 수 없는 이유로 오답처리를 받아 확인 중 [원본 문제(Archives 부분)](https://ncna-region.unl.edu/2020-2021-welcome-page#archive)의 테스트케이스를 얻을 수 있었다.  
```std::cin.eof()```를 이용하여 for문을 돌려 처리하려고 하였으나 어째서인지 케이스가 23개를 넘어갈 때 input이 터져 예상하지 못한 결과가 나왔다.  
결국 input 부분은 다른 사람의 코드를 활용하여 정답을 억지로 받았다.  
가뜩이나 구현 문제에 약한데 푸는 내내 불편했고, 정답을 받아낸 후에도 기분이 몹시 찜찜했던 문제.
