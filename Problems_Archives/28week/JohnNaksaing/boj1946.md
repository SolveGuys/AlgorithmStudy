# 백준 1946 멀티탭 스케줄링
 
### 난이도 : 실버 1
[문제 보러가기](https://www.acmicpc.net/problem/1946)
  
## 그리디
테스트케이스가 엄청나게 많은 문제이므로, 완전 탐색```(O(n^2))```으로는 풀 수 없는 문제였습니다.  
메모리 	2532KB, 시간 396ms

서류/면접 중 둘 중 하나라도 작을 수 없고, 자신보다 상위호환의 점수를 가진 경우 합격할 수 없으니 서류를 기준으로 아래로 내려갈수록 무조건 면접 점수는 지금까지의 최대점을 받아야 합니다.
  
## 자료구조
처음에는 점수 두 개를 담는 구조체의 벡터를 사용했으나, 그 중 하나를 인덱스로 사용하면 정렬할 필요가 없음을 깨달았습니다.  
counting sort의 아이디어를 담은 자료구조입니다.  
```c++
std::vector<int> score_2s(n);
```
이후 입력을 받을 때, ```int idx,score2;```를 입력받아 각 배열에 인덱스로 직접 접근하여 값을 넣어주면 되겠습니다.  


## 알고리즘
```c++
int highest_score2 = INF;
int cnt = 0;
for (int i = 0; i < score_2s.size(); i++) 
{
    if (highest_score2 > score_2s[i])
        highest_score2 = score_2s[i], cnt++;
}
std::cout << cnt << '\n';
```
무조건 앞 놈들보다 더 나은 면접점수를 받아야 하는 슬픈 모습을 코드로 구현해 보았습니다.  


## 코드
[코드 보러가기](./boj1946.cpp)

## ref
[카운팅 소트](./https://www.geeksforgeeks.org/counting-sort/)

## 느낀 점
다음 테스트케이스에서 혼동이 있었다.
```
10

1 2
2 10
3 9
4 8
5 7
6 6
7 5
8 4
9 3
10 1
```
맨 윗줄 (1,2)만 제외한다면 나머지를 모두 뽑을 수 있어 답은 9가 되어야 하지 않나? 라고 생각했기 때문이었다.  
그래서 서류 - 면접의 절대값 차를 키로 하여 내림차순으로 정렬한 다음 어쩌고저쩌고...  
해보려다가 알고 보니 그런 식으로 특정 지원자는 제외할 수 없고, 상위 호환인 점수의 경우 무조건 채용이었다.  
  
그리고 문제 키워드(서류,면접,채용,탈락)가 마음에 들지 않았다. 그리디라고 해서 가져와봤는데 왠지 어딘가가 불편해지는 문제.