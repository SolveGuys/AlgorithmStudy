# 백준 15685 드래곤 커브
 
### 난이도 : 골드 4
[문제 보러가기](https://www.acmicpc.net/problem/15685)
  
## 구현, 삼성SW
전형적인 삼성SW식 구현 문제였습니다.  
프랙탈 규칙이 좀 까다롭고 xy가 꼬여 있기 때문에 그림을 그려 가면서 푸는 걸 추천합니다.  
메모리 	2036KB, 시간 0ms
  
  
## 자료구조
클래스 curve를 선언해주었습니다.
```c++
class curve 
{
	int x, y, d, g;
	std::stack<int> m_sDirections;
}
```
모든 클래스들이 드래곤 커브를 그려나가면서 지나는 점을 기록하기 위해 map이라는 배열을 전역으로 선언했습니다.  
지금 생각해보면 정적변수로 만들어도 [0으로 초기화가 되니](https://hydroponicglass.tistory.com/182) 괜찮았을 것 같습니다.  
스택을 쓰는 이유는 알고리즘상 세대가 바뀔 때마다 끝점에서부터 역방향으로 방향을 꺼내와야 하기 때문입니다.

## 알고리즘
커브가 맵 밖으로 넘어가지 않음이 보장되어 있기 때문에 ```bool bValid(int x, int y)```같은 함수는 만들지 않았습니다.  

```c++
void curve::grow() 
{
	//other gens
	for (int _ = 0; _ < g; _++)
	{
		std::stack<int> s_temp = m_sDirections;
		int size = s_temp.size();
		for (int i = 0; i < size; i++)
		{
			d = s_temp.top();
			s_temp.pop();

			d = (d + 1) % 4;
			x += dx[d];
			y += dy[d];

			map[x][y] = true;

			m_sDirections.push(d);
		}
	}
}

int main()
{
	while(N--)
		curve(x,y,d,g).grow();
}
```
0세대는 curve의 생성자에서 그려집니다.  
1세대부터 g세대까지는 위 코드를 이용해서 기록할 수 있습니다.  
x와 y는 항상 객체가 지나오면서 지금까지 그린 마지막 좌표를 기억하고 있음을 알 수 있습니다.

## 느낀 점
```C++
d = (d + 1) % 4;
x += dx[d];
y += dy[d];
map[x][y] = true;
```
좌표가 꼬여 ```dx[],dy[]```를 정의하거나 [문제](https://www.acmicpc.net/problem/15685)의 예제 3번이 왜 틀리게 나왔는지 같은 고민이 많았다.   
쉽게 디버깅이랑 print를 남발할 수 있는 visual studio가 아니라 프로그래머스 같은 코딩테스트용 IDE에서 문제를 풀었다면 지금처럼 일주일을 써도 성공하기 힘들었을 것 같다.  
시간을 많이 쓴 것과는 별개로 삼성SW문제는 많이 풀어봐야겠다. 아직도 배열의 XY좌표를 헷갈리는 등 찐빠를 많이 내는 것은 갈 길이 멀다는 신호라고 해석이 된다.  
특히 좌표 꼬기는 실전 코테에서도 많이 부족했던 부분이기 때문에, 풀기 싫고 어려운 것과는 별개로 많이 도전해야 함을 느낀다.  

## 주의할 점
좌표의 오른쪽으로 이동하는 것은 문제에서는 x좌표가 +1이 되는 것이나, 자료구조(여기 풀이에서는 배열)에서는 두번째 인덱스(```map[i][j]```에서 j)가 증가하는 것이기 때문에, j에 해당하는 dy를 +1해야 합니다.  
아니면 다른 풀이들처럼 입력 단계에서부터 x와 y를 꼬아서 받는 방법도 있으나, 저는 선호하지 않는 방법이기 때문에 패스했습니다.  

## refs
[참고한 풀이](https://velog.io/@skyepodium/백준-15685-드래곤-커브)

## 코드
[코드 보러가기](./boj15685.cpp)