
# 프로그래머스 60060 가사 검색


### 난이도 : 레벨 '4'

[문제 보러가기](https://programmers.co.kr/learn/courses/30/lessons/60060)
  
## 이분 탐색
일반적인 구현으로 풀면 효율성 테스트에서 시간초과로 통과할 수 없습니다. 

아래는 시간초과 나는 풀이
```C++
std::vector<int> solution(std::vector<std::string> words, std::vector<std::string> queries) {
    int wssize = words.size();
    int qssize = queries.size();
    std::vector<int> answer(qssize,0);
    
    for(int i = 0; i < qssize; i++)
    {
        std::string query = queries[i];
        int qsize = query.size();
        
        bool bFront = false;
        int k = 0;
        if(query[0] == '?')
        {
            bFront = true;
            while(query[k] != '?') k++;
        }
        
        for(int j = 0; j < wssize; j++)
        {
            std::string word = words[j];
            
            if(word.size() != qsize) continue;
            
            //word vs query
            for(int k_ = k; k_ < qsize; k_++)
            {
                if(word[k_] != query[k_] && query[k_] != '?') break;
                
                if(bFront)
                {
                    if(k_ == word.size() -1) answer[i]++;        
                }
                else
                {
                    if(query[k_] == '?') {answer[i]++; break;}
                }
            }
        }
    }
    
    return answer;
}
```
카카오 트라이라는 자료구조를 사용하거나 

## 자료구조

### ```distance_table``` 클래스

생성자에서 input으로 주어진 매개변수들을 넘겨 처리하였습니다.
1~n까지가 아니라 0~n-1까지 범위를 잡았으므로 구현 시 범위 연산자 처리에 신경쓰면서 접근해야 할 필요가 있습니다.


### 정답 구하기

```C++
int distance_table::get_dist(int s, int a, int b) 
{
	int answer = INT_MAX;
	for (int i = 0; i < n; i++) 
	{
		//if(distances[s-1][i] != INT_MAX && distances[i][a-1] != INT_MAX && distances[i][b-1] != INT_MAX)
        answer = std::min(answer,distances[s-1][i] + distances[i][a-1] + distances[i][b-1]);
	}
	return answer;
}	
```
플로이드 와셜로 구한 거리들을 이용하여 최소 환승 거리를 찾아 반환합니다.


## 기타 시행착오

### if문
i == j == k인 경우 continue 등 if문은 안쓰는게 더 성능 빠르게 나옵니다


### INT_MAX 문제
초기화 시 INF로 거리를 줄 때 INT_MAX끼리 더하다가 오버플로우 나와서 틀리는 경우가 생기므로, 충분히 크지만 넉넉하게 작은 수로 잡아야 통과할 수 있습니다.

## 전체 코드
[코드 보러가기](./prog60060.cpp)
