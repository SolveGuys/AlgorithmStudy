# BOJ 1256 두 원
 

### 난이도 : 골드 3
[문제 보러가기](https://www.acmicpc.net/problem/1256)


## DP 안쓰고 푼 DP문제
메모리 	2020KB, 시간 0ms


## 풀이
일단 a를 n개, b를 m개 구하는 방법을 알아야 하기 때문에 nCr의 구현이 필요하다. nCr를 빠르게 구하는 함수는 스택오버플로우에서 가져옴.  
그런데 next_permutation으로 k번 돌리고 문자열을 뱉는 방법은 200C100 ~= 10^59라서 짤없이 시간제한에 걸린다.  
일반적인 풀이들은 여기서 DP를 이용하는데, n+m번만큼만 nCr을 호출하면 되기 때문에 시간제한에 걸리지는 않는다.


## k번째 순서 구하기
a/z의 사전순 배열에서 맨 앞자리는 a 또는 z를 놓을 수 있다.  
맨 앞자리에 a를 놓는 경우는 나머지 n+m-1개 자리에서 a는 n-1개, z는 m개를 놓는 경우의 수이다.  
만약 k가 저 n+m-1Cm보다 큰 수라면 a를 놓는 모든 방법보다 뒤에 있으므로 앞자리는 z가 와야 한다.  
나머지 자리들에 대해서도 같은 방법으로 진행하면 되므로 반복문 또는 재귀를 사용해서 풀면 된다. 


## 느낀 점
논리에는 문제가 없는데 자꾸 오답 뜨길래 알아봤더니 nCr을 구하는 부분에서의 오버플로우 문제가 있었다.
```C++
long int result = n;
for (int i = 2; i <= k; ++i) {
    result *= (n - i + 1);
    result /= i;

    if (result > MAX) 
    {
        result = MAX;
        break;
    }
}
return result;
```
long int로 크기를 키우고 MAX값을 선언하여 넘으면 모두 MAX를 주는 등의 처리를 해주어야 한다.


## 코드 보러가기
[코드](./boj1256.cpp)
