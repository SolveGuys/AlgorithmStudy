
# 백준 2216 문자열과 점수
 

### 난이도 : 골드 3

[문제 보러가기](https://www.acmicpc.net/problem/2216)
  

## 동적 계획법
메모리 30268kb, 시간 52ms

## DP
B와 C가 항상 음수임은 문제의 조건을 따졌을 때 직관적으로 자명하기 때문에, 가장 비슷한 문자열을 만들어 가면서 점수를 덜 깎아먹는 방법으로 접근하는 문제임을 파악할 수 있습니다.  
n < 3000인 경우에서 문자를 모두 만들고 판별하는 브루트포스로는 해결할 수 없는 문제임을 알 수 있습니다.

## 자료구조
dp[i][j] 형태로 이차원의 배열을 만들고, str1에서 i만큼, str2에서 j만큼 substr을 가져와 만들었을 때 가장 높은 점수를 기록하는 배열을 만들었습니다.
```std::vector<std::vector<int>>``` 형태는 단순 이차원 배열보다 메모리를 조금 더 소모하지만 테스트케이스 대비 큰 차이는 아니었다고 생각했습니다.

## 알고리즘
dp[i][j], dp[i+1][j], dp[i][j+1]에서 dp[i+1][j+1]을 결정하는 경우의 수는 다음과 같습니다.
1. dp[i][j]에서 공백 추가 없이 [i+1]번째 char와 [j+1]번째 char를 비교하는 방법(str1, str2 모두 하나씩 가져와 쓰는 방법)
    - [i+1], [j+1]이 같아 A점을 받는 경우
    - [i+1], [j+1]이 달라 C점을 받는 경우
2. dp[i+1][j]에서 B점을 더하고 공백을 하나 채우는 방법
3. dp[i][j+1]에서 B점을 더하고 공백을 하나 채우는 방법

문자열 비교 시 앞의 substr이 뒤에 영향을 미치지 않으므로, greedy하게 접근할 수 있습니다.
이렇게 배열을 만들고 이차원 배열의 맨 끝(문자열의 모든 부분을 이용하여 만든 최고 점수)의 값을 가져와 출력하면 정답을 구할 수 있습니다.

## 전체 코드
[코드 보러가기](./boj2216.cpp)
